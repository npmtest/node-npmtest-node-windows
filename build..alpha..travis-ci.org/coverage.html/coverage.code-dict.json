{"/home/travis/build/npmtest/node-npmtest-node-windows/test.js":"/* istanbul instrument in package npmtest_node_windows */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-windows/lib.npmtest_node_windows.js":"/* istanbul instrument in package npmtest_node_windows */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_windows = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_windows = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-windows/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-windows && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_windows */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_windows\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_windows.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_windows.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_windows.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_windows.__dirname + '/lib.npmtest_node_windows.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/node-windows.js":"/**\n * @class nodewindows\n * This is a standalone module, originally designed for internal use in [NGN](http://github.com/thinkfirst/NGN).\n * However; it is capable of providing the same features for Node.JS scripts\n * independently of NGN.\n *\n * ### Getting node-windows\n *\n * `npm install -g node-windows`\n *\n * ### Using node-windows\n *\n * `var nw = require('node-windows');`\n *\n * @singleton\n * @author Corey Butler\n */\nif (require('os').platform().indexOf('win32') < 0){\n  throw 'node-windows is only supported on Windows.';\n}\n\n// Add binary invokers\nmodule.exports = require('./binaries');\n\n// Add command line shortcuts\nvar commands = require('./cmd');\nfor (var item in commands){\n  module.exports[item] = commands[item];\n}\n\n// Add daemon management capabilities\nmodule.exports.Service = require('./daemon');\nmodule.exports.EventLogger = require('./eventlog');\n","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/binaries.js":"var path = require('path'),\n    bin = path.join(__dirname,'..','bin'),\n    exec = require('child_process').exec;\n\nvar params = function(options,callback) {\n  callback = callback || function(){};\n  options = options || {};\n  if (typeof options === 'function'){\n    callback = options;\n    options = {};\n  }\n  if (typeof options !== 'object'){\n    throw 'Invalid options parameter.';\n  }\n  return {options:options,callback:callback};\n}\n\nmodule.exports = {\n  /**\n   * @method elevate\n   * @member nodewindows\n   * Elevate is similar to `sudo` on Linux/Mac. It attempts to elevate the privileges of the\n   * current user to a local administrator. Using this does not require a password, but it\n   * does require that the current user have administrative privileges. Without these\n   * privileges, the command will fail with a `access denied` error.\n   *\n   * On systems with UAC enabled, this may prompt the user for permission to proceed:\n   *\n   * ![UAC Prompt](http://upload.wikimedia.org/wikipedia/en/5/51/Windows_7_UAC.png)\n   *\n   * **Syntax**:\n   *\n   * `elevate(cmd[,options,callback])`\n   *\n   * @param {String} cmd\n   * The command to execute with elevated privileges. This can be any string that would be typed at the command line.\n   * @param {Object} [options]\n   * Any options that will be passed to `require('child_process').exec(cmd,<OPTIONS>,callback)`.\n   * @param {Function} callback\n   * The callback function passed to `require('child_process').exec(cmd,options,<CALLBACK>)`.\n   */\n  elevate: function(cmd,options,callback) {\n    var p = params(options,callback);\n    exec('\"'+path.join(bin,'elevate','elevate.cmd')+'\" '+cmd,p.options,p.callback);\n  },\n\n  /**\n   * @method sudo\n   * @member nodewindows\n   * Sudo acts similarly to `sudo` on Linux/Mac. Unlike _elevate_, it requires a password, but it\n   * will not prompt the user for permission to proceed. Like _elevate_, this\n   * _still requires administrative privileges_ for the user, otherwise the command will fail.\n   * The primary difference between this and _elevate()_ is the prompt.\n   *\n   * **Syntax**:\n   *\n   * `sudo(cmd,password[,options,callback])`\n   *\n   * @param {String} cmd\n   * The command to execute with elevated privileges. This can be any string that would be typed at the command line.\n   * @param {String} password\n   * The password of the user\n   * @param {Object} [options]\n   * Any options that will be passed to `require('child_process').exec(cmd,<OPTIONS>,callback)`.\n   * @param {Function} [callback]\n   * The callback function passed to `require('child_process').exec(cmd,options,<CALLBACK>)`.\n   */\n  sudo: function(cmd,password,options,callback){\n    password = password || '';\n    if (typeof password !== 'string'){\n      callback = options;\n      options = password;\n      password = '';\n    }\n    var p = params(options,callback);\n    exec(path.join(bin,'sudowin','sudo.exe')+' '+(password !== '' ? '-p '+password:'')+cmd,p.options,p.callback);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/cmd.js":"var exec = require('child_process').exec,\n    bin = require('./binaries');\n\nmodule.exports = {\n\n  /**\n   * @method isAdminUser\n   * @member nodewindows\n   * This asynchronous command determines whether the current user has administrative privileges.\n   * It passes a boolean value to the callback, returning `true` if the user is an administrator\n   * or `false` if it is not.\n   * @param {Function} callback\n   * @param {Boolean} callback.isAdmin\n   * Receives true/false as an argument to the callback.\n   */\n  isAdminUser: function(callback){\n    exec('NET SESSION',function(err,so,se){\n      if (se.length !== 0){\n        bin.elevate('NET SESSION',function(_err,_so,_se){\n          callback(_se.length === 0);\n        });\n      } else {\n        callback(true);\n      }\n    });\n  },\n\n  /**\n   * @method kill\n   * @member nodewindows\n   * Kill a specific process\n   * @param {Number} PID\n   * Process ID\n   * @param {Boolean} [force=false]\n   * Force close the process.\n   * @param {Function} [callback]\n   */\n  kill: function(pid,force,callback){\n    if (!pid){\n      throw new Error('PID is required for the kill operation.');\n    }\n    callback = callback || function(){};\n    if (typeof force == 'function'){\n      callback = force;\n      force = false;\n    }\n    exec(\"taskkill /PID \"+pid+(force==true?' /f':''),callback);\n  },\n\n  /**\n   * @method list\n   * @member nodewindows\n   * List the processes running on the server.\n   * @param {Function} callback\n   * Receives the process object as the only callback argument\n   * @param {Boolean} [verbose=false]\n   */\n  list: function(callback,verbose){\n    verbose = typeof verbose == 'boolean' ? verbose : false;\n    exec('tasklist /FO CSV'+(verbose==true?' /V':''),function(err,stdout,stderr){\n      var p = stdout.split('\\r\\n');\n      var proc = [];\n      var head = null;\n      while (p.length > 1){\n        var rec = p.shift();\n        rec = rec.replace(/\\\"\\,/gi,'\";').replace(/\\\"|\\'/gi,'').split(';');\n        if (head == null){\n          head = rec;\n          for (var i=0;i<head.length;i++){\n            head[i] = head[i].replace(/ /gi,'');\n          }\n        } else {\n          var tmp = {};\n          for (var i=0;i<rec.length;i++){\n            tmp[head[i]] = rec[i].replace(/\\\"|\\'/gi,'');\n          }\n          proc.push(tmp);\n        }\n      }\n      callback(proc);\n    });\n  }\n\n};","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/daemon.js":"/**\n * @class nodewindows.Service\n * This utility can be used to manage node.js scripts as Windows services.\n *\n * **Please note that like all Windows services, creating one requires administrative privileges**.\n *\n * To create a service with node-windows, prepare a script like:\n *\n *      var Service = require('node-windows').Service;\n *\n *      // Create a new service object\n *      var svc = new Service({\n *        name:'Hello World',\n *        description: 'The nodejs.org example web server.',\n *        script: 'C:\\\\path\\\\to\\\\helloworld.js')\n *      });\n *\n *      // Listen for the \"install\" event, which indicates the\n *      // process is available as a service.\n *      svc.on('install',function(){\n *        svc.start();\n *      });\n *\n *      svc.install();\n *\n * The code above creates a new `Service` object, providing a pretty name and description.\n * The `script` attribute identifies the Node.js script that should run as a service. Upon running\n * this, the script will be visible from the Windows Services utility.\n *\n * ![Windows Service](https://raw.github.com/coreybutler/node-windows/master/docs/service.png)\n */\nvar exec = require('child_process').exec,\n    path = require('path'),\n    fs = require('fs'),\n    PermError = 'Permission Denied. Requires administrative privileges.',\n    wincmd = require('./binaries'),\n    Logger = require('./eventlog'),\n    daemonDir = 'daemon',\n    wrapper = path.resolve(path.join(__dirname,'./wrapper.js'));\n\n// BEGIN SUPER AWFUL HACK TO GET AROUND WINSW.EXE ISSUE! REPLACE ASAP!!!!\n// winsw.exe immediately responds with nothing, indicating success, even though\n// it continues processing with the \"install\" method.\nvar sleep = function(period){\n  var st = new Date().getTime();\n  while(new Date().getTime() <= st+(period*1000)){}\n  return;\n};\n\n// The daemon class\nvar daemon = function(config){\n\n  /**\n   * @cfg {Array|Object} [env]\n   * An optional array or object used to pass environment variables to the node.js script.\n   * You can do this by setting environment variables in the service config, as shown below:\n   *\n   *     var svc = new Service({\n   *      name:'Hello World',\n   *      description: 'The nodejs.org example web server.',\n   *      script: 'C:\\\\path\\\\to\\\\helloworld.js',\n   *      env: {\n   *        name: \"NODE_ENV\",\n   *        value: \"production\"\n   *      }\n   *     });\n   *\n   * You can also supply an array to set multiple environment variables:\n   *\n   *     var svc = new Service({\n   *      name:'Hello World',\n   *      description: 'The nodejs.org example web server.',\n   *      script: 'C:\\\\path\\\\to\\\\helloworld.js',\n   *      env: [{\n   *        name: \"HOME\",\n   *        value: process.env[\"USERPROFILE\"] // Access the user home directory\n   *      },{\n   *        name: \"NODE_ENV\",\n   *        value: \"production\"\n   *      }]\n   *     });\n   */\n  Object.defineProperties(this,{\n    _name: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: config.name || null\n    },\n\n    _eventlog:{\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: null\n    },\n\n    _xml: {\n      enumerable: false,\n      get: function(){\n        var wrapperArgs = [\n          '--file', this.script,\n          '--log', this.name + ' ' + 'wrapper',\n          '--grow', this.grow,\n          '--wait', this.wait,\n          '--maxrestarts', this.maxRestarts,\n          '--abortonerror', (this.abortOnError==true?'y':'n'),\n          '--stopparentfirst', this.stopparentfirst\n        ];\n\n        if (this.maxRetries!==null)\n        {\n          wrapperArgs.push('--maxretries');\n          wrapperArgs.push(this.maxRetries);\n        }\n\n        return require('./winsw').generateXml({\n          name: this.name,\n          id: this._exe,\n          nodeOptions: this.nodeOptions,\n          script: wrapper,\n          wrapperArgs: wrapperArgs,\n          description: this.description,\n          logpath: this.logpath,\n          env: config.env,\n          logOnAs: this.logOnAs,\n          workingdirectory: this.workingdirectory,\n          stopparentfirst: this.stopparentfirst,\n          stoptimeout: this.stoptimeout\n        });\n      }\n    },\n\n    _exe: {\n      enumerable: false,\n      get: function(){\n        return this.id+'.exe';\n      }\n    },\n\n    /**\n     * @cfg {Number} [maxRetries=null]\n     * The maximum number of restart attempts to make before the service is considered non-responsive/faulty.\n     * Ignored by default.\n     */\n    maxRetries: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.maxRetries || null\n    },\n    \n    /**\n     * @cfg {Boolean} [stopparentfirst=false]\n     * Allow the service to shutdown cleanly.\n     */\n    stopparentfirst: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.stopparentfirst\n    },\n    \n    /**\n     * @cfg {Number} [stoptimeout=30]\n     * How long to wait in seconds before force killing the application.\n     * This only takes effect when stopparentfirst is enabled.\n     */\n    stoptimeout: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.stoptimeout || 30\n    },\n    \n    /**\n     * @cfg {string} [nodeOptions='--harmony']\n     * Options to be passed to the node process.\n     */\n    nodeOptions: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.nodeOptions || '--harmony'\n    },\n\n    /**\n     * @cfg {Number} [maxRestarts=3]\n     * The maximum number of restarts within a 60 second period before haulting the process.\n     * This cannot be _disabled_, but it can be rendered ineffective by setting a value of `0`.\n     */\n    maxRestarts: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.maxRestarts || 3\n    },\n\n    /**\n     * @cfg {Boolean} [abortOnError=false]\n     * Setting this to `true` will force the process to exit if it encounters an error that stops the node.js script from running.\n     * This does not mean the process will stop if the script throws an error. It will only abort if the\n     * script throws an error causing the process to exit (i.e. `process.exit(1)`).\n     */\n    abortOnError: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.abortOnError instanceof Boolean ? config.abortOnError : false\n    },\n\n    /**\n     * @cfg {Number} [wait=1]\n     * The initial number of seconds to wait before attempting a restart (after the script stops).\n     */\n    wait: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: !isNaN(config.wait) ? config.wait : 1\n    },\n\n    /**\n     * @cfg {Number} [grow=.25]\n     * A number between 0-1 representing the percentage growth rate for the #wait interval.\n     * Setting this to anything other than `0` allows the process to increase it's wait period\n     * on every restart attempt. If a process dies fatally, this will prevent the server from\n     * restarting the process too rapidly (and too strenuously).\n     */\n    grow: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: !isNaN(config.grow) ? config.grow : .25\n    },\n\n    _directory: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: config.script !== null ? path.dirname(config.script) : null\n    },\n\n    /**\n     * Resolves the directory where the script is saved.\n     */\n    directory: {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: function(dir){\n        if (this.script == null || this.name == null){\n          throw Error('Script and Name are required but were not provided.');\n        }\n        if (dir){\n          this._directory = path.resolve(dir);\n        }\n        return path.resolve(path.join(this._directory,daemonDir));\n      }\n    },\n\n    /**\n     * @property {String} root\n     * The root directory where the process files are stored.\n     */\n    root: {\n      enumerable: true,\n      get: function(){ return this.directory();}\n    },\n\n    // Generates the primary logging utility\n    log: {\n      enumerable: false,\n      get: function(){\n        if (this._eventlog !== null)\n          return this._eventlog;\n        if (this.name == null)\n          throw 'No name was specified for the service';\n        this._eventlog = new Logger(this.name+' Monitor');\n        return this._eventlog;\n      }\n    },\n\n    // The path where log files should be stored\n    logpath: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.logpath || null\n    },\n\n    // The log mode. Options are the same as winsw#generateXml\n    logmode: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.logmode || 'rotate'\n    },\n\n    // The name of the process\n    name: {\n      enumerable: false,\n      get: function(){return this._name;},\n      set: function(value){this._name = value;}\n    },\n\n    // The ID for the process\n    id: {\n      enumerable: true,\n      get: function(){\n        return this.name.replace(/[^\\w]/gi,'').toLowerCase();\n      }\n    },\n\n    // Description of the service\n    description: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: config.description || ''\n    },\n\n    /**\n     * @property {Object} [user]\n     * If you need to specify a specific user or particular credentials to manage a service, the following\n     * attributes may be helpful.\n     *\n     * The `user` attribute is an object with three keys: `domain`,`account`, and `password`.\n     * This can be used to identify which user the service library should use to perform system commands.\n     * By default, the domain is set to the local computer name, but it can be overridden with an Active Directory\n     * or LDAP domain. For example:\n     *\n     * **app.js**\n     *\n     *     var Service = require('node-windows').Service;\n     *\n     *     // Create a new service object\n     *     var svc = new Service({\n     *       name:'Hello World',\n     *       script: require('path').join(__dirname,'helloworld.js')\n     *     });\n     *\n     *     svc.user.domain = 'mydomain.local';\n     *     svc.user.account = 'username';\n     *     svc.user.password = 'password';\n     *     ...\n     *\n     * Both the account and password must be explicitly defined if you want the service module to\n     * run commands as a specific user. By default, it will run using the user account that launched\n     * the process (i.e. who launched `node app.js`).\n     */\n    user: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: {\n        account: null,\n        password: null,\n        domain: process.env.COMPUTERNAME\n      }\n    },\n    /**\n     * @property {Object} [logOnAs]\n     * If you need to specify a specific user or particular credentials for the service log on as once installed, the following\n     * attributes may be helpful.\n     *\n     * The `logOnAs` attribute is an object with four keys: `domain`,`account`, `password`, and `mungeCredentialsAfterInstall`.\n     * This can be used to identify which user the service should run as once installed.\n     *\n     * If no account and password is specified, the logOnAs property is not used and the service will run as the \"Local System\" account.\n     * If account and password is specified, but domain is not specified then the domain is set to the local computer name, but it can be overridden with an Active Directory\n     * or LDAP domain. For example:\n     *\n     * **app.js**\n     *\n     *     var Service = require('node-windows').Service;\n     *\n     *     // Create a new service object\n     *     var svc = new Service({\n     *       name:'Hello World',\n     *       script: require('path').join(__dirname,'helloworld.js')\n     *     });\n     *\n     *     svc.logOnAs.domain = 'mydomain.local';\n     *     svc.logOnAs.account = 'username';\n     *     svc.logOnAs.password = 'password';\n     *     ...\n     *\n     * Both the account and password must be explicitly defined if you want the service to log on as that user,\n     * otherwise the Local System account will be used.\n     */\n    logOnAs: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: {\n        account: null,\n        password: null,\n        domain: process.env.COMPUTERNAME,\n        mungeCredentialsAfterInstall: true\n      }\n    },\n\n    /**\n     * @property {String} [workingdirectory]\n     * The full path to the working directory that the service process\n     * should launch from. If this is omitted, it will default to the\n     * current processes working directory.\n     */\n    workingdirectory: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: process.cwd()\n    },\n\n    // Optionally provide a sudo password.\n    sudo: {\n      enumerable:false,\n      writable: true,\n      configurable: false,\n      value: {\n        password: null\n      }\n    },\n\n    /**\n     * @cfg {String} script\n     * The absolute path of the script to launch as a service.\n     * @required\n     */\n    script: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: config.script !== undefined ? require('path').resolve(config.script) : null\n    },\n\n    /**\n     * @cfg {String} execPath\n     * The absolute path to the executable that will launch the script.\n     * If omitted process.execPath is used.\n     */\n    execPath: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: config.execPath !== undefined ? require('path').resolve(config.execPath) : null\n    },\n\n    /**\n     * @method install\n     * Install the script as a process.\n     * @param {String} [dir=root of script]\n     * The directory where the process files will be saved. Defaults to #script path.\n     * @param {Function} [callback]\n     * The callback to fire when the installation completes.\n     */\n    /**\n     * @event install\n     * Fired when the installation process is complete.\n     */\n    /**\n     * @event alreadyinstalled\n     * Fired if the script is already known to be a service.\n     */\n    /**\n     * @event invalidinstallation\n     * Fired if an installation is detected but missing required files.\n     */\n    /**\n     * @event error\n     * Fired in some instances when an error occurs.\n     */\n    install: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: function(dir){\n        if (this.script == null || this.name == null){\n          throw Error('Script and Name are required but were not provided.');\n        }\n\n        if (this.exists){\n          var missing = false;\n          if (!fs.existsSync(path.join(this.root,this._exe))){\n            this.log.warn('The main executable is missing or cannot be found ('+path.join(this.root,this._exe)+')');\n            missing = true;\n          }\n          if (!fs.existsSync(path.join(this.root,this.id+'.xml'))){\n            this.log.warn('The primary configuration file is missing or cannot be found ('+path.join(this.root,this.id+'.xml')+')');\n            missing = true;\n          }\n          if (missing.length > 0){\n            this.emit('invalidinstallation');\n            return;\n          }\n          this.log.warn('The process cannot be installed again because it already exists.');\n          this.emit('alreadyinstalled');\n          return;\n        }\n\n        var winsw = require('./winsw'), me = this;\n\n        if (typeof dir === 'function'){\n          callback = dir;\n          dir = null;\n        }\n        dir = this.directory(dir);\n\n        // If the output directory does not exist, create it.\n        fs.exists(dir,function(exists){\n          if (!exists){\n            fs.mkdirSync(dir);\n          }\n          // Write the configuration file\n          fs.writeFile(path.resolve(dir,me.id+'.xml'),me._xml,function(){\n            // Write the exe file\n            winsw.createExe(me.id,dir,function(){\n              me.execute('\"'+path.resolve(dir,me._exe)+'\" install',function(){\n                sleep(2);\n                me.emit('install');\n              });\n            });\n          });\n        });\n      }\n    },\n\n    /**\n     * @method uninstall\n     * Uninstall the service.\n     * @param {Number} [waitTime]\n     * Seconds to wait until winsw.exe finish processing the uninstall command.\n     *\n     *      var Service = require('node-windows').Service;\n     *\n     *      // Create a new service object\n     *      var svc = new Service({\n     *        name:'Hello World',\n     *        script: require('path').join(__dirname,'helloworld.js')\n     *      });\n     *\n     *      // Listen for the \"uninstall\" event so we know when it's done.\n     *      svc.on('uninstall',function(){\n     *        console.log('Uninstall complete.');\n     *        console.log('The service exists: ',svc.exists);\n     *      });\n     *\n     *      // Uninstall the service.\n     *      svc.uninstall();\n     */\n    /**\n     * @event uninstall\n     * Fired when the uninstall is complete.\n     */\n    /**\n     * @event alreadyuninstalled\n     * Fired if the script is unknown as a service.\n     */\n    uninstall: {\n      enumerable: true,\n      writable: false,\n      value: function(waitTime){\n        var me = this;\n        waitTime = waitTime || 2; // The same wait time as in the install method\n\n        if (!this.exists){\n          console.log('Uninstall was skipped because process does not exist or could not be found.');\n          this.emit('alreadyuninstalled');\n          return;\n        }\n\n        var uninstaller = function(){\n          // Uninstall the process\n          me.execute('\"'+path.resolve(me.root,me._exe)+'\" uninstall',function(error,stdout,stderr){\n            if (error){\n              me.checkPermError(error);\n            } else if (stderr.trim().length > 0){\n              console.log('Error: ',stderr);\n            } else {\n              sleep(waitTime); // Wait for uninstall to fully finish\n\n              var rm = function(file){\n                if (fs.existsSync(path.join(me.root,file))){\n                  fs.unlinkSync(path.join(me.root,file));\n                }\n              };\n\n              // Remove the daemon files individually to prevent security warnings.\n              rm(me.id+'.xml');\n\n              // Remove known wrappers\n              rm(me.id+'.wrapper.log');\n              rm(me.id+'.out.log');\n              rm(me.id+'.err.log');\n\n              // Remove the executable and executable .NET runtime config file\n              rm(me.id+'.exe');\n              rm(me.id+'.exe.config');\n\n              // Remove all other files\n              var _files = fs.readdirSync(me.root);\n              _files.forEach(function(f){\n                rm(f);\n              });\n\n              if (me.root !== path.dirname(me.script)){\n                fs.rmdir(me.root,function(){\n                  sleep(1);\n                  me.emit('uninstall');\n                });\n              } else {\n                me.emit('uninstall');\n              }\n            }\n          });\n        };\n\n        this.once('stop',uninstaller);\n        this.once('alreadystopped',uninstaller);\n        this.stop();\n      }\n    },\n\n    /**\n     * @method start\n     * Start an existing method.\n     */\n    /**\n     * @event start\n     * Fired when the event has started.\n     */\n    start: {\n      enumerable: true,\n      writable: false,\n      configurable: false,\n      value: function(){\n        var me = this;\n\n        if (this.name == null){\n          throw \"A name for the service is required.\";\n        }\n\n        if (!this.exists){\n          throw Error('The service \"'+this.name+'\" does not exist or could not be found.');\n        }\n\n        this.execute('NET START \"'+me._exe+'\"',function(err,stdout,stderr){\n          if (err){\n            if (err.code == 2){\n              if (err.message.indexOf('already been started') >= 0 && err.message.indexOf('service name is invalid') < 0){\n                me.log.warn('An attempt to start the service failed because the service is already running. The process should be stopped before starting, or the restart method should be used.');\n                me.emit('error',err);\n                return;\n              } else if (err.message.indexOf('service name is invalid') < 0){\n                me.checkPermError(err);\n                console.log(err);\n                me.emit('error',err);\n                return;\n              }\n            } else {\n              me.log.error(err.toString());\n            }\n          } else {\n            me.emit('start');\n          }\n        })\n      }\n    },\n\n    /**\n     * @method stop\n     * Stop the service.\n     */\n    /**\n     * @event stop\n     * Fired when the service is stopped.\n     */\n    stop: {\n      enumerable: true,\n      writable: false,\n      value: function(){\n        var me = this;\n\n        me.execute('NET STOP \"'+me._exe+'\"',function(err,stdout,stderr){\n          if (err){\n            if (err.code == 2){\n              me.log.warn('An attempt to stop the service failed because the service is/was not running.');\n              me.emit('alreadystopped');\n            } else {\n              me.checkPermError(err);\n            }\n          } else {\n            me.log.info(stdout);\n            //sleep(10); // Wait for stop to complete.\n            me.emit('stop');\n          }\n        });\n      }\n    },\n\n    /**\n     * @method restart\n     * Restart an existing service\n     */\n    restart: {\n      enumerable: true,\n      writable: false,\n      value: function(callback){\n        var me = this;\n        this.once('stop',me.start);\n        this.stop();\n      }\n    },\n\n    /**\n     * @property {Boolean} exists\n     * Determine whether the service exists.\n     */\n    exists: {\n      enumerable: true,\n      get: function(){\n        if (this.script == null || this.name == null){\n          throw Error('Script and name are required but were not specified.');\n        }\n        return fs.existsSync(path.join(this.directory(),this.id+'.exe')) && fs.existsSync(path.join(this.directory(),this.id+'.xml')) ;\n      }\n    },\n\n    // Execute commands with elevated privileges.\n    execute: {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: function(cmd,options,callback) {\n        var me = this;\n        callback = callback || function(){};\n        options = options || {};\n\n        wincmd.isAdminUser(function(isAdmin){\n          if (isAdmin) {\n            if (typeof options === 'function'){\n              callback = options;\n              options = {};\n            }\n            if (me.user.account !== null && me.user.password !== null){\n              _cmd = \"runas /profile /user:\"+me.user.domain+\"\\\\\"+me.user.account+\" \"+cmd;\n              exec(cmd,options,callback);\n            } else if (me.sudo.password !== null){\n              // If the user is not an admin, but a sudo password is provided for admin,\n              // attempt to launch using sudo.\n              wincmd.sudo(cmd,me.sudo.password||'',options,callback);\n            } else {\n              wincmd.elevate(cmd,options,callback)\n            }\n          } else {\n            console.log(PermError);\n            throw PermError;\n          }\n        });\n      }\n    },\n\n    // Check for permission errors\n    checkPermError: {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: function(error){\n        if (error.message.indexOf('Administrator access') >= 0 || error.message.indexOf('Access is denied') >= 0){\n          try {this.log.error(PermError);} catch(e){console.log(PermError);}\n        } else {\n          try {this.log.error(error.toString());} catch(e) {console.log(error.toString());}\n        }\n        process.exit(1);\n      }\n    }\n  });\n};\n\nvar util = require('util'),\n    EventEmitter = require('events').EventEmitter;\n\n// Inherit Events\nutil.inherits(daemon,EventEmitter);\n\n// Export functionality for the module.\nmodule.exports = daemon;\n","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/eventlog.js":"/**\n * @class nodewindows.EventLogger\n * @since 0.1.0\n * Use a _non-C++_ based event logging utility with your Windows code.\n * This utility can write to the event log, making your logs visible from the Event Viewer.\n *\n * To create a logger:\n *\n *     var EventLogger = require('node-windows').EventLogger;\n *\n *     var log = new EventLogger('Hello World');\n *\n *     log.info('Basic information.');\n *     log.warn('Watch out!');\n *     log.error('Something went wrong.');\n *\n * Looks similar to:\n *\n * ![Event Logging in node-windows](https://raw.github.com/coreybutler/node-windows/master/docs/eventlog.png)\n *\n * Some lesser-used options are also available through node-windows event logging.\n *\n *    log.auditSuccess('AUser Login Success');\n *    log.auditFailure('AUser Login Failure');\n *\n * Each log type (info, warn, error, auditSuccess, and auditFailure) method optionally accepts two additional\n * arguments, including a _code_ and _callback_. By default, the event code is `1000` if not otherwise specified.\n * To provide a custom event code with a log message and write that message to the console, the following code could\n * be used:\n *\n *     log.info('Something different happened!', 1002, function(){\n *       console.log('Something different happened!');\n *     });\n *\n * By default, event logs are all part of the `APPLICATION` scope. However; it is also possible to use the `SYSTEM` log.\n * To do this, a configuration object must be passed to the new log:\n *\n *     var EventLogger = require('node-windows').EventLogger;\n *     var log = new EventLogger({\n *       source: 'My Event Log',\n *       eventLog: 'SYSTEM'\n *     });\n */\nvar wincmd = require('./binaries'),\n    eventlogs = ['APPLICATION','SYSTEM'],\n    validtypes = ['ERROR','WARNING','INFORMATION','SUCCESSAUDIT','FAILUREAUDIT'];\n\n// Write a message to the log. This will create the log if it doesn't exist.\nvar write = function(log,src,type,msg,id,callback){\n\n  if (msg == null) {return};\n  if (msg.trim().length == 0) {return};\n\n  log = log || 'APPLICATION';\n  log = eventlogs.indexOf(log.toUpperCase()) >= 0 ? log : 'APPLICATION';\n  type = (type || 'INFORMATION').trim().toUpperCase();\n  type = (validtypes.indexOf(type.trim().toUpperCase()) >= 0 ? type : 'INFORMATION').trim().toUpperCase();\n  id = typeof id == 'number' ? (id > 0 ? id : 1000) : 1000;\n  src = (src || 'Unknown Application').trim();\n\n  wincmd.elevate(\"eventcreate /L \"+log+\" /T \"+type+\" /SO \\\"\"+src+\"\\\" /D \\\"\"+msg+\"\\\" /ID \"+id,callback);\n};\n\n// Basic functionality\nvar logger = function(config){\n\n  config = config || {};\n\n  if (typeof config == 'string') {\n    config = {\n      source: config\n    };\n  }\n\n  // Common attributes\n  Object.defineProperties(this,{\n\n    /**\n     * @cfg {String} [name=Node.js]\n     * The source of the log information. This is commonly the title of an application\n     * or the Node.js script name (i.e. MyApp).\n     */\n    source: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: config.source || 'Node.js'\n    },\n\n    _logname: {\n      enumerable: false,\n      writable: true,\n      configurable: false,\n      value: config.eventLog || 'APPLICATION'\n    },\n\n    /**\n     * @cfg {String} [eventLog=APPLICATION]\n     * The event log where messages should be written. This is either `APPLICATION` or `SYSTEM`.\n     */\n    eventLog: {\n      enumerable: true,\n      get: function(){\n        return this._logname.toUpperCase();\n      },\n      set: function(value) {\n        if (value){\n          this._logname = eventlogs.indexOf(value.toUpperCase()) >= 0 ? value.toUpperCase() : 'APPLICATION';\n        }\n      }\n    },\n\n    /**\n     * @method info\n     * Log an informational message.\n     * @param {String} message\n     * The content of the log message.\n     * @param {Number} [code=1000]\n     * The event code to assign to the message.\n     * @param {Function} [callback]\n     * An optional callback to run when the message is logged.\n     */\n    info: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: function(message,code,callback) {\n        write(this.eventLog,this.source,'INFORMATION',message,code,callback);\n      }\n    },\n\n    information: {\n      enumerable: false,\n      get: function(){\n        return this.info;\n      }\n    },\n\n    /**\n     * @method error\n     * Log an error message.\n     * @param {String} message\n     * The content of the log message.\n     * @param {Number} [code=1000]\n     * The event code to assign to the message.\n     * @param {Function} [callback]\n     * An optional callback to run when the message is logged.\n     */\n    error: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: function(message,code,callback) {\n        write(this.eventLog,this.source,'ERROR',message,code,callback);\n      }\n    },\n\n    /**\n     * @method warn\n     * Log a warning message.\n     * @param {String} message\n     * The content of the log message.\n     * @param {Number} [code=1000]\n     * The event code to assign to the message.\n     * @param {Function} [callback]\n     * An optional callback to run when the message is logged.\n     */\n    warn: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: function(message,code,callback) {\n        write(this.eventLog,this.source,'WARNING',message,code,callback);\n      }\n    },\n\n    warning: {\n      enumerable: false,\n      get: function(){return this.warn;}\n    },\n\n    /**\n     * @method auditSuccess\n     * Log an audit success message.\n     * @param {String} message\n     * The content of the log message.\n     * @param {Number} [code=1000]\n     * The event code to assign to the message.\n     * @param {Function} [callback]\n     * An optional callback to run when the message is logged.\n     */\n    auditSuccess: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: function(message,code,callback) {\n        write(this.eventLog,this.source,'SUCCESSAUDIT',message,code,callback);\n      }\n    },\n\n    /**\n     * @method auditFailure\n     * Log an audit failure message.\n     * @param {String} message\n     * The content of the log message.\n     * @param {Number} [code=1000]\n     * The event code to assign to the message.\n     * @param {Function} [callback]\n     * An optional callback to run when the message is logged.\n     */\n    auditFailure: {\n      enumerable: true,\n      writable: true,\n      configurable: false,\n      value: function(message,code,callback) {\n        write(this.eventLog,this.source,'FAILUREAUDIT',message,code,callback);\n      }\n    }\n  });\n};\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/winsw.js":"module.exports = {\n\n  /**\n   * @method generateXml\n   * Generate the XML for the winsw configuration file.\n   * @param {Object} config\n   * The config object must have the following attributes:\n   *\n   * - *id* This is is how the service is identified. Alphanumeric, no spaces.\n   * - *name* The descriptive name of the service.\n   * - *script* The absolute path of the node.js server script. i.e. in this case\n   *  it's the wrapper script, not the user's server script.\n   *\n   * Optional attributes include\n   *\n   * - *description* The description that shows up in the service manager.\n   * - *nodeOptions* Array or space separated string of node options (e.g. '--harmony')\n   * - *wrapperArgs* additional arguments to pass to wrapper script to control restarts, etc.\n   * - *logmode* Valid values include `rotate` (default), `reset` (clear log), `roll` (move to .old), and `append`.\n   * - *logpath* The absolute path to the directory where logs should be stored. Defaults to the current directory.\n   * - *dependencies* A comma delimited list or array of process dependencies.\n   * - *env* A key/value object or array of key/value objects containing\n   * environment variables to pass to the process. The object might look like `{name:'HOME',value:'c:\\Windows'}`.\n   * - *logOnAs* A key/value object that contains the service logon credentials.\n   * The object might look like `{account:'user', password:'pwd', domain:'MYDOMAIN'}\n   * If this is not included or does not have all 3 members set then it is not used.\n   * - *workingdirectory* optional working directory that service should run in.\n   * If this is not included, the current working directory of the install process\n   * is used.\n   */\n  generateXml: function(config)\n  {\n    var xml;\n\n    // add multiple \"tag\" items to the xml\n    // if input is an array, add each element of the array, if it's a string,\n    // split it around splitter and add each one\n    // if input is null or undefined do nothing\n    function multi(tag, input, splitter)\n    {\n      // do nothing if no input\n      if (input===undefined || input===null) {\n        return;\n      }\n\n      if (!(input instanceof Array)) {\n        input = input.split(splitter||',');\n      }\n      input.forEach(function(val) {\n        var ele={};\n        ele[tag]=String(val).trim();\n        xml.push(ele);\n      });\n    }\n\n    // Make sure required configuration items are present\n    if (!config || !config.id || !config.name || !config.script)\n    {\n      throw \"WINSW must be configured with a minimum of id, name and script\";\n    }\n\n    // create json template of xml\n    // only the portion of the xml inside the top level 'service' tag\n    xml = [\n      {id: config.id},\n      {name: config.name},\n      {description: config.description||''},\n      {executable: process.execPath},\n      {logmode: config.logmode||'rotate'}\n    ];\n\n    multi('argument',config.nodeOptions, ' ');\n    xml.push({argument:config.script.trim()});\n    multi('argument',config.wrapperArgs,' ');\n\n\n    // Optionally add log path\n    if (config.logpath) {\n      xml.push({logpath : config.logpath});\n    }\n\n    // Optionally add stopparentprocessfirst\n    if (config.stopparentfirst) {\n      xml.push({stopparentprocessfirst: config.stopparentfirst});\n    }\n    \n    // Optionally set the stoptimeout\n    if (config.stoptimeout) {\n      xml.push({stoptimeout: config.stoptimeout + 'sec'});\n    }\n\n    // Optionally add service dependencies\n    multi('depend',config.dependencies);\n\n    // Optionally add environment values\n    if (config.env) {\n      config.env = (config.env instanceof Array == true) ?\n        config.env : [config.env];\n      config.env.forEach(function(env){\n        xml.push({env: {_attr: {name:env.name, value:env.value}}});\n      });\n    }\n\n    // optionally set the service logon credentials\n    if (config.logOnAs && config.logOnAs.account && config.logOnAs.password &&\n      config.logOnAs.domain)\n    {\n      xml.push({\n        serviceaccount: [\n          {domain: config.logOnAs.domain},\n          {user: config.logOnAs.account},\n          {password: config.logOnAs.password}\n        ]\n      });\n    }\n\n    // if no working directory specified, use current working directory\n    // that this process was launched with\n    xml.push({workingdirectory: config.workingdirectory || process.cwd()});\n\n    // indent resultant xml with tabs, and use windows newlines for extra readability\n    return require('xml')({service:xml}, {indent: '\\t'}).replace(/\\n/g,'\\r\\n');\n  },\n\n  /**\n   * Copy install version of winsw.exe to specific renamed version according to\n   * the service id. Also copy .exe.config file that allows it to run under\n   * .NET 4+ runtime on newer versions of windows.\n   * (see https://github.com/kohsuke/winsw#net-runtime-40)\n   *\n   * @method createExe\n   * Create the executable\n   * @param {String} name\n   * The alphanumeric string (spaces are stripped) of the `.exe` file. For example, `My App` generates `myapp.exe`\n   * @param {String} [dir=cwd]\n   * The output directory where the executable will be saved.\n   * @param {Function} [callback]\n   * The callback to fire upon completion.\n   */\n  createExe: function(name,dir,callback) {\n    var fs = require('fs'), p = require('path');\n\n    if (typeof dir === 'function') {\n      callback = dir;\n      dir = null;\n    }\n\n    dir = dir || process.cwd();\n\n    var exeOrigin = p.join(__dirname,'..','bin','winsw','winsw.exe'),\n        cfgOrigin = p.join(__dirname,'..','bin','winsw','winsw.exe.config'),\n        exeDest = p.join(dir,name.replace(/[^\\w]/gi,'').toLowerCase()+'.exe'),\n        cfgDest = p.join(dir,name.replace(/[^\\w]/gi,'').toLowerCase()+'.exe.config'),\n        exeData = fs.readFileSync(exeOrigin,{encoding:'binary'}),\n        cfgData = fs.readFileSync(cfgOrigin,{encoding:'binary'});\n\n    fs.writeFileSync(exeDest,exeData,{encoding:'binary'});\n    fs.writeFileSync(cfgDest,cfgData,{encoding:'binary'});\n    callback && callback();\n  }\n}","/home/travis/build/npmtest/node-npmtest-node-windows/node_modules/node-windows/lib/wrapper.js":"// Handle input parameters\nvar Logger = require('./eventlog'),\n    optimist = require('optimist'),\n    max = 60,\n    p = require('path'),\n    argv = optimist\n      .demand('file')\n      .alias('f','file')\n      .describe('file','The absolute path of the script to be run as a process.')\n      .check(function(argv){\n        require('fs').existsSync(p.resolve(argv.f),function(exists){\n          return exists;\n        });\n      })\n      .alias('d','cwd')\n      .describe('cwd','The absolute path of the current working directory of the script to be run as a process.')\n//      .check(function(argv){\n//        require('fs').existsSync(p.resolve(argv.d),function(exists){\n//          return exists;\n//        });\n//      })\n      .demand('log')\n      .alias('l','log')\n      .describe('log','The descriptive name of the log for the process')\n      .default('eventlog','APPLICATION')\n      .alias('e','eventlog')\n      .describe('eventlog','The event log container. This must be APPLICATION or SYSTEM.')\n      .default('maxretries',-1)\n      .alias('m','maxretries')\n      .describe('maxretries','The maximim number of times the process will be auto-restarted.')\n      .default('maxrestarts',5)\n      .alias('r','maxrestarts')\n      .describe('maxrestarts','The maximim number of times the process should be restarted within a '+max+' second period shutting down.')\n      .default('wait',1)\n      .alias('w','wait')\n      .describe('wait','The number of seconds between each restart attempt.')\n      .check(function(argv){\n        return argv.w >= 0;\n      })\n      .default('grow',.25)\n      .alias('g','grow')\n      .describe('grow','A percentage growth rate at which the wait time is increased.')\n      .check(function(argv){\n        return (argv.g >= 0 && argv.g <= 1);\n      })\n      .default('abortonerror','no')\n      .alias('a','abortonerror')\n      .describe('abortonerror','Do not attempt to restart the process if it fails with an error,')\n      .check(function(argv){\n        return ['y','n','yes','no'].indexOf(argv.a.trim().toLowerCase()) >= 0;\n      })\n      .default('stopparentfirst', 'no')\n      .alias('s', 'stopparentfirst')\n      .describe('stopparentfirst', 'Allow the script to exit using a shutdown message.')\n      .check(function(argv){\n        return ['y','n','yes','no'].indexOf(argv.a.trim().toLowerCase()) >= 0;\n      })\n      .argv,\n    log = new Logger(argv.e == undefined ? argv.l : {source:argv.l,eventlog:argv.e}),\n    fork = require('child_process').fork,\n    script = p.resolve(argv.f),\n    wait = argv.w*1000,\n    grow = argv.g+1,\n    attempts = 0,\n    startTime = null,\n    starts = 0,\n    child = null\n    forcekill = false;\n\nif (argv.d){\n  if (!require('fs').existsSync(p.resolve(argv.d))){\n    console.warn(argv.d+' not found.');\n    argv.d = process.cwd();\n  }\n  argv.d = p.resolve(argv.d);\n}\n\nif (typeof argv.m === 'string'){\n  argv.m = parseInt(argv.m);\n}\n\n// Set the absolute path of the file\nargv.f = p.resolve(argv.f);\n\n// Hack to force the wrapper process to stay open by launching a ghost socket server\nvar server = require('net').createServer().listen();\n\n/**\n * @method monitor\n * Monitor the process to make sure it is running\n */\nvar monitor = function() {\n  if(!child || !child.pid) {\n\n    // If the number of periodic starts exceeds the max, kill the process\n    if (starts >= argv.r){\n      if (new Date().getTime()-(max*1000) <= startTime.getTime()){\n        log.error('Too many restarts within the last '+max+' seconds. Please check the script.');\n        process.exit();\n      }\n    }\n\n    setTimeout(function(){\n      wait = wait * grow;\n      attempts += 1;\n      if (attempts > argv.m && argv.m >= 0){\n        log.error('Too many restarts. '+argv.f+' will not be restarted because the maximum number of total restarts has been exceeded.');\n        process.exit();\n      } else {\n        launch('warn', 'Restarted ' + wait + ' msecs after unexpected exit; attempts = ' + attempts);\n      }\n    },wait);\n  } else {\n    // reset attempts and wait time\n    attempts = 0;\n    wait = argv.w * 1000;\n  }\n};\n\n\n/**\n * @method launch\n * A method to start a process.\n * logLevel - optional logging level (must be the name of a function the the Logger object)\n * msg - optional msg to log\n */\nvar launch = function(logLevel, msg) {\n\n  if (forcekill) {\n    log.info(\"Process killed\");\n    return;\n  }\n\n  //log.info('Starting '+argv.f);\n  if (logLevel && msg) {\n    log[logLevel](msg);\n  }\n\n  // Set the start time if it's null\n  if (startTime == null) {\n    startTime = startTime || new Date();\n    setTimeout(function(){\n      startTime = null;\n      starts = 0;\n    },(max*1000)+1);\n  }\n  starts += 1;\n\n  // Fork the child process\n  var opts = {env:process.env};\n  if (argv.d) opts.cwd = argv.d;\n  if (argv.s) opts.detached = true;\n  child = fork(script,opts);\n\n  // When the child dies, attempt to restart based on configuration\n  child.on('exit',function(code){\n    log.warn(argv.f+' stopped running.');\n\n    // If an error is thrown and the process is configured to exit, then kill the parent.\n    if (code !== 0 && argv.a == \"yes\"){\n      log.error(argv.f+' exited with error code '+code);\n      process.exit();\n      //server.unref();\n    } else if (forcekill) {\n      process.exit();\n    }\n\n    child = null;\n    // Monitor the process\n    monitor();\n  });\n};\n\nvar killkid = function(){\n  forcekill = true;\n  if (argv.s) {\n    child.send('shutdown');\n  } else {\n    child.kill();\n  }\n}\n\nprocess.on('exit', killkid);\nprocess.on(\"SIGINT\", killkid);\nprocess.on(\"SIGTERM\", killkid);\n\n// Launch the process\nlaunch('info', 'Starting ' + argv.f);"}